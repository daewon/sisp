<html>
<head>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app17.us.archive.org";archive_analytics.values.server_ms=294;</script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<link rel="stylesheet" type="text/css" href="style.css" />
<title>Chapter 3: Parser</title>
</head>
<body>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(imgWidth,imgHeight,yearImgWidth,monthImgWidth){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.lwh.jp/lisp/parser.html";

var firstYear = 1996;
var displayDay = "27";
var displayMonth = "May";
var displayYear = "2013";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})(525, 27, 25, 2);//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>
<div id="wm-ipp" lang="en" style="display:none;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="/web/" title="Wayback Machine home page"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.lwh.jp/lisp/parser.html" style="width:400px;" onfocus="this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20130527195844" /><input type="submit" value="Go" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    Apr
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 19:58:44 May 27, 2013">MAY</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="/web/20141012145156/http://www.lwh.jp/lisp/parser.html" title="12 Oct 2014"><strong>OCT</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                       <img src="/static/images/toolbar/wm_tb_prv_off.png" alt="Previous capture" width="14" height="16" border="0" />
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 19:58:44 May 27, 2013">27</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="/web/20141012145156/http://www.lwh.jp/lisp/parser.html" title="14:51:56 Oct 12, 2014"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   2012
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 19:58:44 May 27, 2013">2013</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="/web/20141012145156/http://www.lwh.jp/lisp/parser.html" title="12 Oct 2014"><strong>2014</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="/web/20130527195844*/http://www.lwh.jp/lisp/parser.html" title="See a list of every capture for this URL">3 captures</a>
           <div class="r" title="Timespan for captures of this URL">27 May 13 - 9 Dec 14</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines"
		 onmouseover="__wm.st(1)" onmouseout="__wm.st(0)"
		 onmousemove="__wm.mv(event,this)"
		 width="525"
		 height="27"
		 border="0"
		 src="/web/jsp/graph.jsp?graphdata=525_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:000000000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:4:000010000000_2014:-1:000000000101_2015:-1:000000000000_2016:-1:000000000000" />
       </div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>
<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->


<h1>Parser</h1>

<p>
The next stage in our project is <i>parsing</i>: taking a line of text
from the user (or elsewhere), and creating the data objects it represents.
Naturally the user might type something which does not represent an
object according to our definitions, in which case we must have some way
to signal an <i>error</i>.
</p>

<h3>Errors</h3>

<p>
Here is a definition of an <code>Error</code> type:
<pre class="c">
typedef enum {
	Error_OK = 0,
	Error_Syntax
} Error;
</pre>
If, like me, you learned to program in BASIC on microcomputers, you
will be familiar with the dreaded <code>SYNTAX ERROR</code>. Now is our
chance to see things from the other side of the fence. Most of our
functions from now on will return an <code>Error</code> to indicate
whether and how something went wrong.
</p>

<h2>Lexer</h2>

<p>
I have no formal training in CS, but as far as I understand it the idea is
to split a string up into <i>tokens</i>, which are both "words" and
"punctuation", and discard any insignificant white space. So if the
input is:
<pre class="lisp">
(foo bar)
</pre>
Then the four tokens are:
<table border="1">
<tr>
 <td><code>(</code></td>
 <td><code>foo</code></td>
 <td><code>bar</code></td>
 <td><code>)</code></td>
</tr>
</table>
</p>

<p>
So let's start by creating a <i>lexer</i>, which will return the start
and end of the next token in a string.
</p>

<pre class="c">
int lex(const char *str, const char **start, const char **end)
{
	const char *ws = " \t\n";
	const char *delim = "() \t\n";
	const char *prefix = "()";

	str += strspn(str, ws);

	if (str[0] == '\0') {
		*start = *end = NULL;
		return Error_Syntax;
	}

	*start = str;

	if (strchr(prefix, str[0]) != NULL)
		*end = str + 1;
	else
		*end = str + strcspn(str, delim);

	return Error_OK;
}
</pre>

<p>
If our lexer hits the end of the string without finding a token (ie,
the remainder of the string is entirely white space), then it will
return a syntax error and set the start and end to <code>NULL</code>.
</p>

<h2>Parser</h2>

<p>
Now we can think about the parser itself. The entry point
is <code>read_expr</code>, which will read a single (possibly complex)
object and return the error status and a pointer to the remainder of
the input.
<pre class="c">
int read_expr(const char *input, const char **end, Atom *result);
</pre>
</p>

<p>
We will first deal with the simple data: integers, symbols and
<code>NIL</code>. If you have a regex library available then this is
easy, but it's not too bad in plain C either.
</p>

<pre class="c">
int parse_simple(const char *start, const char *end, Atom *result)
{
	char *buf, *p;

	/* Is it an integer? */
	long val = strtol(start, &amp;p, 10);
	if (p == end) {
		result->type = AtomType_Integer;
		result->value.integer = val;
		return Error_OK;
	}

	/* NIL or symbol */
	buf = malloc(end - start + 1);
	p = buf;
	while (start != end)
		*p++ = toupper(*start), ++start;
	*p = '\0';

	if (strcmp(buf, "NIL") == 0)
		*result = nil;
	else
		*result = make_sym(buf);

	free(buf);

	return Error_OK;
}
</pre>

<p>
Notice two things: first, we are converting the input to upper case.
This isn't strictly necessary &mdash; there's nothing wrong with having
a case-sensitive lisp &mdash; but it is the traditional behaviour.
Secondly, <code>NIL</code> is a special case: it's parsed directly as
<code>AtomType_Nil</code>, rather than leaving it as a symbol.
</p>

<p>
If you're familiar with the various dialects of LISP then you will know
that <code>NIL</code> is not necessarily the same as <code>()</code>,
the <i>empty list</i>. We could choose to treat <code>NIL</code> as a
symbol which evaluates to itself, but for this project we will consider
both representations to be <em>exactly</em> the same.
</p>

<p>
Next up are lists (including improper lists and pairs). The simplified
list syntax makes this a little complicated, so we'll stick it all in a
helper function. Once again recursion allows us to deal with nested
lists.
</p>

<pre class="c">
int read_list(const char *start, const char **end, Atom *result)
{
	Atom p;

	*end = start;
	p = *result = nil;

	for (;;) {
		const char *token;
		Atom item;
		Error err;

		err = lex(*end, &amp;token, end);
		if (err)
			return err;

		if (token[0] == ')')
			return Error_OK;

		if (token[0] == '.' &amp;&amp; *end - token == 1) {
			/* Improper list */
			if (nilp(p))
				return Error_Syntax;

			err = read_expr(*end, end, &amp;item);
			if (err)
				return err;

			cdr(p) = item;

			/* Read the closing ')' */
			err = lex(*end, &amp;token, end);
			if (!err &amp;&amp; token[0] != ')')
				err = Error_Syntax;

			return err;
		}

		err = read_expr(token, end, &amp;item);
		if (err)
			return err;

		if (nilp(p)) {
			/* First item */
			*result = cons(item, nil);
			p = *result;
		} else {
			cdr(p) = cons(item, nil);
			p = cdr(p);
		}
	}
}
</pre>

<p>
I dislike writing infinite loops, but this is the clearest layout I have
come up with so far. Let me know if you can write a better one!
</p>

<p>
Finally we have <code>read_expr</code> itself, which is very simple now
that we have done all of the hard work:
<pre class="c">
int read_expr(const char *input, const char **end, Atom *result)
{
	const char *token;
	Error err;

	err = lex(input, &amp;token, end);
	if (err)
		return err;

	if (token[0] == '(')
		return read_list(*end, end, result);
	else if (token[0] == ')')
		return Error_Syntax;
	else
		return parse_simple(token, *end, result);
}
</pre>
The check for a closing bracket will catch invalid forms such as
<pre class="lisp">)</pre> and <pre class="lisp">(X .)</pre>
</p>

<h4>Testing</h4>

<p>
If we use the parser to create a simple read-print loop, then the we
can type representations of objects on the console and check that they
are parsed correctly.
</p>

<pre class="c">
int main(int argc, char **argv)
{
	char *input;

	while ((input = readline("&gt; ")) != NULL) {
		const char *p = input;
		Error err;
		Atom expr;

		err = read_expr(p, &amp;p, &amp;expr);

		switch (err) {
		case Error_OK:
			print_expr(expr);
			putchar('\n');
			break;
		case Error_Syntax:
			puts("Syntax error");
			break;
		}

		free(input);
	}

	return 0;
}
</pre>

<p>
This version uses the <i>readline</i> library, which shows a prompt
and reads a line of text from the console. It supports editing beyond
what a dumb terminal can provide, but a simple wrapper around
<code>fgets()</code> will do just as well.
</p>

<pre class="lisp">
&gt; <b>42</b>
42
&gt; <b>(foo bar)</b>
(FOO BAR)
&gt; <b>(s (t . u) v . (w . nil))</b>
(S (T . U) V W)
&gt; <b>()</b>
NIL
</pre>

<p>
Looks good! Remember that <code>()</code> is exactly the same as
<code>NIL</code>, and that <code>(X Y)</code> is just another way of
writing <code>(X . (Y . NIL))</code>.
</p>

</body>
</html>






<!--
     FILE ARCHIVED ON 19:58:44 May 27, 2013 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 16:28:56 Jan 20, 2016.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
